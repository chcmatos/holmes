import UInt64 from "./uint64"

/**
 * Pseudo-Random-Number-Generator (PRNG)
 *
 * An object with functions to generate pesudo-random numbers following the article algorithm rules below,
 * published in `Harvey Mudd College` by `Melissa E. O’Neill`.
 *
 * ABSTRACT
 *
 * This paper presents a new uniform pseudorandom number generation scheme that is both extremely practical and statistically good (easily passing L’Ecuyer’s TestU01 suite [29]). It has a number of important properties, including solid mathematical foundations, good time and space performance, small code size, multiple random streams, and better cryptographic properties than are typical for a general-purpose generator.
 *
 * The key idea is to pass the output of a fast well-understood “medium quality” random number generator to an efficient permutation function (a.k.a. hash function), built from composable primitives, that enhances the quality of the output. The algorithm can be applied at variety of bit sizes, including 64 and 128 bits (which provide 32- and 64-bit outputs, with periods of 264 and 2128). Optionally, we can provide each b -bit generator with a b −1 bit stream-selection constant, thereby providing 2b−1 random streams, which are full period and entirely distinct. An extension adds up to 2b -dimensional equidistribution for a total period of 2b 2b . The construction of the permutation function and the period- extension technique are both founded on the idea of permutation functions on tuples.
 *
 * In its standard variants, b -bit generators use a 2b /2 -to-1 function to produce b /2 bits of output. These functions can be designed to make it difficult for an adversary to discover the generator’s internal state by examining its output, and thus make it challenging to predict. This property, coupled with the ability to easily switch between random streams, provides many of the benefits provided by cryptographically secure generators without the overheads usually associated with those generators.
 *
 * see more here: http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf
 */
export default class PRNG {
  //#region constants
  private static readonly multiplicator = UInt64.parseDigits(
    0x58,
    0x51,
    0xf4,
    0x2d,
    0x4c,
    0x95,
    0x7f,
    0x2d
  )
  private static readonly incrementer = UInt64.parseDigits(
    0x14,
    0x05,
    0x7b,
    0x7e,
    0xf7,
    0x67,
    0x81,
    0x4f
  )
  private static readonly mask = UInt64.parseDigits(
    0x00,
    0x00,
    0x00,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff
  )
  //#endregion

  //#region singleton mode
  private static _instance: PRNG

  public static get instance(): PRNG {
    return this._instance ?? (this._instance = new PRNG())
  }
  //#endregion

  /**
   * Current base state for next request generation.
   */
  private state: UInt64

  /**
   * Pseudo Random Number Generator Constructor.
   *
   * @param seed A random seed (or seed state, or just seed) is a number (or vector) used to initialize a pseudorandom number generator, may be null.
   * see more about seed here: https://en.wikipedia.org/wiki/Random_seed
   */
  constructor(seed?: number) {
    seed = (seed ?? Date.now()) >>> 0
    //initial state
    this.state = PRNG.incrementer.clone()
    this._next()
    this.state = this.state.and(PRNG.mask).or(UInt64.parse(seed))
    this._next()
  }

  private _next(): number {
    /*  save current state  */
    const prevState = this.state.clone()

    /*  advance internal state  */
    this.state.mult(PRNG.multiplicator)
    this.state.add(PRNG.incrementer)

    // calculate: (state ^ (state >> 18)) >> 27
    let output = this.state.clone()
    output.rotateRightShift(18)
    output = output.xor(this.state)
    output.rotateRightShift(27)

    //calculate: state >> 59
    let rot = this.state.clone()
    rot.rotateRightShift(59)

    //calculate: rotate32(xorshifted, rot)
    let k = rot.toNumber()
    let output2 = output.and(PRNG.mask)
    output2.rotateLeftShift(32 - k)
    output.rotateRightShift(k)
    let res = output.xor(output2)
    return res.toNumber()
  }

  /**
   * Generate a pseudo-random number.
   * @param min mininum value or default
   * @param max maximum value or default
   * @returns generated number
   */
  public next(
    min: number = Number.MIN_VALUE,
    max: number = Number.MAX_VALUE
  ): number {
    let n = this._next()
    if (
      (min != Number.MIN_VALUE && n < min) ||
      (max != Number.MAX_VALUE && n > max)
    ) {
      const len = Math.ceil(Math.log10(n + 1))
      n = Math.floor((n / Math.pow(10, len)) * (max - min + 1) + min)
    }
    return n
  }

  /**
   * Generate pseudo-random bytes numbers
   * @param length bytes length
   * @param radix radix number, default `255`
   * @returns generated bytes numbers
   */
  public static nextBytes(length: number, radix: number = 255): number[] {
    if (radix < 0 || radix > 255) {
      throw new Error("Radix out of bounds!")
    }
    return Array.from({ length }, () => PRNG.instance.next() % radix)
  }
}
